use crate::lexer::{Token, LexerError};
use stahl_errors::{Location, PointLC};
use stahl_value::Value;
use stahl_util::{SharedString};

#[LALR]
grammar(loc: &Location);

extern {
    type Location = PointLC;
    type Error = LexerError;

    enum Token {
        "_" => Token::Hole,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
        "|" => Token::Pipe,
        Dedent => Token::Dedent,
        Group => Token::Group,
        Indent => Token::Indent,
        Int => Token::Int(<isize>),
        Newline => Token::Newline,
        String => Token::String(<SharedString>),
        Symbol => Token::Symbol(<SharedString>),
    }
}

pub IExprs = Newline* <IExprsBody*>;
IExprsBody = <IExpr>;

pub IExpr: Value = {
    <h:Head> <b:Body?> => {
        let mut l = h;
        if l.len() == 1 && b.is_none() {
            l.pop().unwrap()
        } else {
            if let Some(b) = b {
                l.extend(b);
            }
            Value::from_iter(l)
        }
    },
};

Head: Vec<Value> = {
    Group <SExpr*> Newline+,
    <SExpr+> Newline+,
};
Body: Vec<Value> = Indent <IExpr+> Dedent Newline*;

SExpr: Value = {
    "(" Newline* <SExprListBody>,
    <l:@L> "_" <r:@R> => Value::Symbol(loc.clone().span_lc(l, r), SharedString::from("_")),
    <l:@L> <n:Int> <r:@R> => Value::Int(loc.clone().span_lc(l, r), n),
    <l:@L> <s:String> <r:@R> => Value::String(loc.clone().span_lc(l, r), s),
    <l:@L> <s:Symbol> <r:@R> => Value::Symbol(loc.clone().span_lc(l, r), s),
};
SExprListBody: Value = {
    <l:@L> <h:SExpr> Newline* <t:SExprListBody> <r:@R> => Value::Cons(
        loc.clone().span_lc(l, r),
        Box::new(h),
        Box::new(t),
    ),
    "|" Newline* <v:SExpr> Newline* ")" => v,
    <l:@L> ")" <r:@R> => Value::Nil(loc.clone().span_lc(l, r)),
};
